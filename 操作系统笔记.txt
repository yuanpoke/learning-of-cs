操作系统 operating system（os）

10/21

#什么是操作系统？
  对上，操作系统是一个控制软件，管理应用程序
  对下，进行硬件资源管理

  “把CPU抽象成进程，磁盘抽象成文件，内存抽象成地址空间”，
  从而供用户更好更便捷地使用
  
  层次结构：硬件之上，应用软件之下，用户之下
  操作系统是系统软件

  （有两种接口，shell和kernel。shell包括gui和命令行程序
    Linux, Windows, Android的界面属于外壳shell，
    内核kernel是本课学习重点）


#计算机系统的层次结构：
     硬件
     操作系统
应用程序 用户（直接接触操作系统）
     用户

1.系统资源的管理者：处理机管理，存储器管理，文件管理，
                    设备管理
2.用户和计算机硬件之间的接口（用户接口）：
    命令接口：允许用户直接使用
      联机命令接口（交互式命令接口）：用户说一句，系统做一句
      脱机命令接口（批处理命令接口）：用户说一堆，系统做一堆
    程序接口：允许用户通过程序间接使用
      由一组系统调用组成，程序接口=系统调用=广义指令，如在程
      序中调用dll
    GUI：图形用户界面
3.对硬件资源的扩展：覆盖了软件的机器称为扩充机器，又称为虚拟机。

**现在很多CPU都是多核的


#系统调用

**系统调用会使处理器从用户态到核心态
**应用程序通过系统调用请求操作系统的服务。凡是与资源有关的操作，
  都必须通过系统调用，从而保证系统的稳定性和安全性。系统调用的
  相关处理需要在核心态下进行（因为需要特权指令）。
系统调用（按功能分类）
  1. 设备管理（这个别忘）
  2. 文件管理
  3. 进程管理
  4. 进程通信
  5. 内存管理
**有的库函数涉及系统调用，有的没涉及。如：取绝对值的库函数不涉及；
  而创建一个新文件的库函数涉及系统调用。
**系统调用背后的过程：
    传递系统调用参数->执行陷入指令trap（用户态）->执行系统调用相应
    服务程序（核心态）->返回用户程序
    **发出系统调用请求是在用户态，系统调用的相应处理在核心态。
    **陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。



#操作系统的四大特征：
  **并发和共享是最基本的特征，互为存在条件的。
  **如果没有并发和共享就谈不上虚拟和异步。
  1. 并发
       并发和并行：并发是一段时间多个程序，并行是同一
                   时刻多个程序。      
  2. 共享：资源可供内存中多个并发执行的进程共同使用
        互斥共享：一个时间段只能一个进程访问资源
        同时共享：一个时间段可以有多个进程访问资源
  3. 虚拟
       一台物理机器虚拟成多台虚拟机器
       空分复用技术：如虚拟存储器技术
       时分复用技术：如虚拟处理器
  4. 异步
       走走停停，不知道向前推进的速度。
       但只要运行环境相同，os要保证程序的运行结果（
       如1+1=2这个结果是不能变的）相同。


#os的发展和分类
  1. 手工操作阶段
       **纸带打孔与否为0或1，
       主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低

  2. 批处理阶段
       a. 单道批处理系统
            **引入脱机输入/输出技术（磁带），有监督程序
            主要优点：缓解一定程度人机速度矛盾，资源利用率有所提升
            主要缺点：内存中仅一道程序运行，CPU大量时间等待I/O
       b. 多道批处理系统（os开始出现）
            **内存读入多道程序，引入中断，多个程序并发
            主要优点：程序并发执行，共享资源，资源利用率大幅提升
            主要缺点：用户响应时间长，没有人机交互功能

  3. 分时操作系统
       **以时间片为单位轮流为各个用户/作业服务，可人机交互
       主要优点：用户请求及时响应，有人机交互。多个用户可同时使用
                 一台计算机。
       主要缺点：不能优先处理一些紧急任务，不区分任务紧急性。

  4. 实时操作系统
       要在严格的时限内处理完事件，主要特点是及时性和可靠性
       分类：
         a. 硬实时系统：必须在规定时间内完成
              如：导弹控制系统、自动驾驶系统
         b. 软实时系统：偶尔可以违反
              如：12306订票系统
       主要优点：能优先响应紧急任务
       
  5. 网络操作系统
  6. 分布式操作系统
  7. 个人计算机操作系统

      

#操作系统实例：
  1.UNIX BSD
      UNIX -> BSD
  2.LINUX(在其学生时代写的)
      -> redhat, ubuntu
  3.Windows
  4.ios  macos
  5.Android

  **计算机桌面Windows大多，服务器、终端Linux大多
  **汇编语言是基于具体的硬件的，很难移植
  **CS：段寄存器

  
#操作系统的启动：
  DISK：存放操作系统，bootloader
  BIOS: 基本I/O处理系统，上电后检测外设，加载软件，把
        bootloader加载到内存中
  bootloader：加载os 
  POST（加电自检），寻找显卡和执行BIOS


#中断

**本质：发生中断就意味着需要操作系统介入，开展管理工作

  1. 当中断发生时，CPU立即进入核心态，使os获得计算机的
     控制器。有了中断，才能实现多道程序并发执行。
  2. 用户态到核心态是通过中断实现的，并且中断是唯一途径。
  3. 核心态到用户态的切换是通过执行一个特权指令，将程序
     状态字PSW的标志位设置为用户态。

中断的分类
  1. 内中断（也称异常、例外、陷入） =》信号来源是CPU内部，和当前指令有关
        a. 自愿中断：指令中断：trap中断
        b. 强迫中断：硬件故障（注意）和软件中断
  2. 外中断（中断）                 =》信号来源是CPU外部，和当前指令无关
        a. 外设请求
        b. 人工干预：用户强行终止



指令
  1. 特权指令：如内存清零指令（不允许用户程序使用）
  2. 非特权指令：如普通的运算指令，两种态下都可执行
 
处理器状态：根据程序状态字寄存器PSW某个标志位
  1. 用户态（目态）：只能执行非特权指令
  2. 核心态（管态）：特权指令、非特权指令都可执行

程序：
  1. 内核程序：系统的管理者
  2. 应用程序： 

操作系统
  1. 内核（更靠近硬件）
       时钟管理、中断处理、原语（都有，更核心的）
       对系统资源进行管理：进程管理、存储器管理、设备管理等（有些内核没有）
  2. 非内核功能

**内核是计算机上配置的底层软件，是os最基本、核心的部分。

os的体系结构
  1. 大内核：主要功能都作为内核
       优点：高性能
       缺点：内核代码庞大，难以维护
  2. 微内核：保留最基本的
       优点：结构清晰，方便维护
       缺点：频繁地在和心态和用户态切换，性能低


#进程
  
**程序：指令序列

**程序段、数据段、PCB组成进程实体（进程映像），进程实体
  简称为进程。创建进程，实质上就是创建进程实体中的PCB，
  撤销进程实质上就是撤销进程实体中的PCB。

**PCB是进程存在的唯一标准。

进程定义：
  定义均强调了动态性，动态性是进程最基本的特征
  1. 进程是程序的一次执行过程。
  2. 进程是一个程序及其数据在处理机上顺序执行时所
     发生的活动。
  3. 进程是具有独立功能的程序在数据集合上运行的过程，
     是系统进行资源分配和调度的一个独立单位。  
  4. 进程是进程实体的运行过程，是系统进行资源分配和调度
     的一个独立单位。

  任务管理器中各个进程。

  严格来说，两者不一样，进程实体是静态的，进程是动态的。
  但是一般认为两者一样，可以说进程由程序段、数据段、PCB
  三部分组成。

PCB的组成：进程的管理者（os）所需的数据都在PCB中，而程序
           本身的允许所需数据在程序段和数据段中
  1. 进程描述信息
       进程标识符PID：操作系统分配的唯一的不重复的ID
       用户标识符UID
  2. 进程控制和管理信息
       进程当前状态
       进程优先级
  3. 资源分配清单
       程序段指针
       数据段指针
       键盘
       鼠标
  4. 处理机相关信息
       各种寄存器值：进程会切换故需要保存在PCB中

进程的组织方式：多个进程之间的组织方式
  1. 链接方式：
       按照进程状态将PCB分为多个队列，os持有指向
       各个队列的指针。队列之间用指针连接。
         执行指针：指向运行态的进程
         就绪队列指针：指向就绪态的进程
         阻塞队列指针：指向阻塞态的进程
       
  2. 索引方式：
       按照进程状态的不同，建立几张索引表，os持有
       指向各个索引表的指针。
         执行指针
         就绪表指针
         阻塞表指针

进程的特征：
  1. 动态性：进程是程序的一次执行
  2. 并发性：
  3. 独立性：独立运行、获得资源、接受调度
             进程是资源分配、接受调度的基本单位。
  4. 异步性：
  5. 结构性：每个进程都有一个PCB，由程序段、数据段和
             PCB组成

进程的状态：
  三种基本状态：
    1. 运行态：占有CPU
         双核环境可以有两个进程在运行态
    2. 就绪态：拥有除CPU外所有资源
    3. 阻塞态（等待态）：缺少某一资源和CPU
  另外两种状态：
    1. 创建态：进程正在被创建，os为其分配资源，初始化PCB
    2. 结束态（终止态）：进程正在撤销，os回收资源，撤销PCB

进程状态的转换：
  就绪态->运行态：进程被调度
  运行态->就绪态：时间片到，或CPU被高优先级进程抢占
  运行态->阻塞态：等待资源分配或某时间发生     
  阻塞态->就绪态：资源分配到位或等待的事件发生

  运行态到阻塞态是进程自身做出的主动行为
  阻塞态到就绪态不是进程自身控制的，是被动的

  不能由阻塞态直接到运行态，也不能由就绪态直接到阻塞态。



10/22

#进程控制：
  进程控制就是实现进程状态的转换
  PCB修改、队列移动，资源分配/回收
  
用原语实现进程控制。原语的特点是执行期间不允许中断。
这种不允许中断的操作称为原子操作。
原语采用关中断指令和开中断指令实现。该两项指令权限
非常高，是只允许在核心态下执行的特权指令。原语属于
核心态，运行在核心态下。
原语是一种特殊的程序。

  关中断指令
  原语代码1
  原语代码2
  开中断指令
  代码3
  代码4

所有原语都做三类事情：
  修改PCB，修改队列，分配/回收资源


进程的创建：
  1. 创建原语：
       申请空白PCB
       分配资源
       初始化PCB
       将PCB插入就绪队列
  2. 引起进程创建的事件：
       用户登录：分时系统中，会为新用户建立进程
       作业调度：多道批处理系统中，当有新作业放入内存中时，
       提供服务
       应用请求

进程的终止：
  1. 撤销原语：
       找到PCB
       若进程正在运行，剥夺CPU
       终止其所有子程序
       回收资源
       删除PCB
  2. 引起进程终止的事件：
       正常结束
       异常结束
       外界干预

进程的阻塞：
  1. 阻塞原语：
       找到PCB
       保护运行现场，PCB状态信息设置为阻塞态，暂停进程
       将PCB插入相应事件的等待队列
  2. 引起进程阻塞的事件：
       等待分配资源
       等待其他进程完成工作（某个事件发生）

进程的唤醒：
  1. 唤醒原语：
       找到PCB
       从等待队列移除，进程状态设置为就绪态
       PCB插入就绪队列
  2. 引起进程唤醒的事件：
       等待的事件发生

**阻塞原语和唤醒原语必须成对地使用，因为都是由于一个等待事件



#进程通信：进程通信就是进程之间的信息交换

**因为进程是分配资源的单位，各进程拥有的内存空间独立。
为了安全，一个进程不能直接访问另一个进程的地址空间。
因此需要进程通信。
  
  1. 共享存储
       **为通信的进程分配一个共享空间（多个进程对其访问必须是互斥的）
       使用P、V操作

       a. 基于数据结构的共享
            （如长度为10的数组）速度慢、限制多，低级通信
       b. 基于存储区的共享
            存储区中数据的形式、位置都由进程控制而不是os
            速度更快，高级通信
  2. 消息传递
       **数据交换以格式化的消息为单位。通过“发送消息/接收消息”两个
         原语进行数据交换。格式化信息包括消息头和消息体。
       
       a. 直接通信方式
            消息直接挂到接收进程的消息缓冲队列上
       b. 间接（信箱）通信方式
            先发送到中间实体（信箱），因此也称为信箱通信方式
  3. 管道通信
       a. 管道是一个共享文件，pipe文件。是在内存中开辟一个大小
          固定的缓冲区。
       b. 管道只能采用半双工通信。如果要实现双向同时通信，要设置
          两个管道。各个进程要互斥地访问管道。
       c. 数据以字符流的形式写入管道，当管道写满时，写进程的write（）
          系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部
          取走后，管道变空，读进程的read（）系统调用将被阻塞。
       d. 如果没有写满，就不允许读。如果没有读空，就不允许写。
       e. 数据一旦被读出，就会被抛弃，故读进程最多只能有一个，否在可能
          会读错数据。


#线程
**两个进程QQ和音乐，而QQ进程中又有视频、传送文件两个线程
**在传统的进程中只能串行地执行程序，通过引入线程来增加并发
**传统的进程是程序执行流的最小单位，现在线程是程序执行流的最小单位
**线程可以理解为“轻量级进程”，线程是一个基本的CPU执行单元
**引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
**相比进程间并发，线程间并发如果在同一进程内线程切换，不需要切换进程
  环境，系统开销小。
**引入后并发性和系统开销都变好了


#线程的属性：
  1. 每个线程都有线程ID、线程控制块TCB
  2. 线程也有就绪、阻塞、运行三种基本状态
  3. 几乎不拥有系统资源
  4. 同一进程不同线程共享进程资源
  5. 共享内存地址空间，线程通信甚至无需系统干预
  6. 不同进程中的线程切换会引起进程切换


#线程的实现方式
  1. 用户级线程ULT
       a. 由应用程序通过线程库实现，所有的线程管理工作都由应用
          程序负责（包括线程切换）
       b. 线程切换在用户态下即可完成，无需操作系统干预
       c. 用户级线程对用户不透明，对操作系统透明
  2. 内核级线程KLT：只有这个是处理机分配的单位
       a. 线程的管理工作由操作系统内核完成，内核级线程的
          切换必须在核心态下完成
  3. 在同时支持用户级线程和内核级线程的系统中，可采用两者结合的方式，
     将n个用户级线程映射到m个内核级线程上（n>=m）
     **os只“看得见”内核级线程，因此只有内核级线程才是处理机
       分配的单位。若某进程有两个内核级线程，三个用户级线程，在用户看
       来，该进程只有三个线程。但即使在4核处理机上运行，最多只能被分配
       到两个核，最多只有两个用户级线程并行执行。

#多线程模型问题
  1. 多对一模型：多个用户级线程映射到一个内核级线程。每个用户进程
                 只对应一个内核级线程。
       a. 优点：用户级线程的切换在用户空间，不需要到核心态，开销小，
                效率高。
       b. 缺点：当一个用户级线程阻塞后，整个进程都会阻塞，并发度不高，
                多个线程不可在多核处理机上并行运行（因为内核级线程是
                处理机调度的基本单位）
  2. 一对一模型：一个用户级线程映射到一个内核级线程。
       a. 优点：一个线程阻塞后，别的线程还能执行，并发能力强。多线程
                可以在多核处理机上并行执行。
       b. 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核
               完成，需要切换到核心态，开销大。
  3. 多对多模型：将n个用户级线程映射到m个内核级线程上（n>=m）
       克服了多对一模型并发度不高，一对一模型一个用户进程占有太多内核级
       线程，开销太大的问题。


#处理机调度

**调度：根据某种规则决定处理任务的先后

**处理机调度：按照某种算法选择一个进程分配处理机

三个层次：
  1. 高级调度（作业调度）
       a. 从外存上后备队列挑选一个或多个作业，分配内存等必要资源，建立
          相应的进程（PCB），以使其获得竞争处理机的权利。
       b. 高级调度是外存和内存之间的调度。每个作业只调入一次，调出一次。
          作业调入时建立PCB，调出时才撤销PCB。
       c. 对进程状态影响：无->创建态->就绪态
  
  2. 中级调度（内存调度）
       a. 虚拟存储技术提高内存利用率和系统吞吐量。
       b. 暂时调到外存等待的进程状态为挂起状态。PCB位置不变一直在内存中，
          记录该进程在外存中位置。被挂起的进程PCB放到挂起队列。
       c. 中级调度（内存调度）就是要决定哪个挂起状态的进程重新进入内存。
       d. 一个进程可能被多次调出、调入内存，因此中级调度的频率比高级调度
          高。
       e. 对进程状态影响：挂起态->就绪态 （阻塞挂起->阻塞态）
       **挂起和阻塞都是暂时不能获得CPU，但挂起态将进程映像调到外存去了，
         阻塞态进程映像还在内存中。

  3. 低级调度（进程调度）
       a. 主要任务就是选取进程分配处理机。
       b. 进程调度是os最基本的调度，频率很高，一般几十毫秒一次。
       c. 对进程状态影响: 就绪态->运行态


#进程调度
  1. 时机
       a. 需要进行进程调度
            当前运行的进程主动放弃处理机（包括发生异常）
            当前运行的进程被动放弃处理机
       b. 不能进行进程调度
            处理中断的过程中

            进程在os内核程序临界区中
                （但进程处于普通临界区是可以处理机调度）
                临界资源：一个时间段只允许一个进程使用的资源
                临界区：访问临界资源的那段代码
                内核程序临界区访问内核数据结构（如就绪队列），没退出临界
                区时会给就绪队列上锁，就不能切换。
            在原子操作过程中（原语）

  2. 切换与过程
       切换过程主要完成了：对原来运行进程数据的保存，对新进程数据的恢复。
       进程的调度、切换是有代价的，频繁开销会很大。

  3. 方式
       a. 非剥夺调度方式（非抢占式）：只允许进程主动放弃处理机
       b. 剥夺调度方式（抢占式）：允许被动放弃处理机（更适合分时、实时os）


#调度算法的评价指标
  1. CPU利用率
       利用率 = 忙碌的时间 / 总时间
     
  2. 系统吞吐量：单位时间完成作业的数量
       系统吞吐量 = 总的作业数 / 总时间

  3. 周转时间：从作业被提交给系统开始，到作业完成为止的时间间隔
       周转时间 = 作业完成时间 - 作业提交时间
       平均周转时间 = 各作业周转时间之和 / 作业数
       带权周转时间 = 作业周转时间 / 作业实际运行时间
         以上三者都是越小越好
       平均带权周转时间 = 各作业带权周转时间之和 / 作业数

  4. 等待时间
       a. 进程等待时间 = 进程建立后等待被服务的时间之和
       b. 作业等待事件 = 建立进程后的等待时间 + 在外存后备队列中等待时间
       
  5. 响应时间：用户提交请求到首次响应的时间
       

#调度算法
  1. 先来先服务FCFS：等待时间越久的越先得到服务
       a. 用于作业调度，考虑哪个作业先到达后备队列；
          用于进程调度，考虑哪个进程先到达就绪队列。
       b. 非抢占式的
       c. 
       d. 
  
  2. 短作业优先SJF


  3. 高响应比优先HRRN




#死锁
 
死锁、饥饿、死循环
  共同点：都是进程无法向前推进
  区别：
    1. 死锁一定是循环等待他方手里的资源，进程至少有两个，处于死锁的进程一定
       是阻塞态。
    2. 饥饿是可能只有一个进程发生饥饿，处于饥饿的进程可能是阻塞态或就绪态。
         （饥饿：长期得不到服务）
    3. 可能只有一个进程发生死循环，可以上处理机运行，可以是运行态。死锁和饥饿
       是管理者（操作系统）的问题，死循环是被管理者的问题（代码没写好）。
  

死锁产生的必要条件（必须全部满足）
  1. 互斥
  2. 不剥夺：资源未使用完不能由其他进程强行夺走
  3. 请求并保持：已保持了至少一个资源，又提出新的资源请求
  4. 循环等待
       发生死锁一定有循环等待，但是发生循环等待不一定有死锁

死锁的处理策略：
  1. 预防死锁。破坏必要条件。
  2. 避免死锁。防止系统进入不安全状态（如银行家算法）。
  3. 死锁的检测和解除。允许死锁发生，检测死锁的发生，采取措施解除死锁。



#设备管理（主机外部设备）

I/O设备
  1. 什么是I/O设备：输入/输出设备（别小看）
       如：鼠标、显示器、移动硬盘、U盘

  2. 按使用特性分类
       人机交互类外部设备：传输速度慢
       存储设备：传输速度快
       网络通信设备：速度中间

  3. 按传输速率分类
       低速设备：鼠标、键盘
       中速设备：激光打印机
       高速设备：磁盘

  4. 按信息交换的单位分类
       块设备：磁盘   速度快，可寻址
       字符设备：鼠标、键盘   速度慢，不可寻址，常用中断驱动


I/0控制器
  **CPU无法直接控制I/O设备的机械部件，CPU控制I/O控制器，而
    I/O控制器控制设备的机械部件。
  功能：
    1. 接受和识别CPU发出的命令：其中控制寄存器存放命令
    2. 向CPU报告设备状态：其中有状态寄存器
    3. 数据交换：其中有数据寄存器
    4. 地址识别：识别是哪个寄存器
  组成：
    








10/23
  














