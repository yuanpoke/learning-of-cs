操作系统 operating system（os）

10/21

#什么是操作系统？
  对上，操作系统是一个控制软件，管理应用程序
  对下，进行硬件资源管理

  “把CPU抽象成进程，磁盘抽象成文件，内存抽象成地址空间”，
  从而供用户更好更便捷地使用
  
  层次结构：硬件之上，应用软件之下，用户之下
  操作系统是系统软件

  （有两种接口，shell和kernel。shell包括gui和命令行程序
    Linux, Windows, Android的界面属于外壳shell，
    内核kernel是本课学习重点）



#计算机系统的层次结构：
     硬件
     操作系统
应用程序 用户（直接接触操作系统）
     用户

1.系统资源的管理者：处理机管理，存储器管理，文件管理，
                    设备管理

2.用户和计算机硬件之间的接口（用户接口）：
    命令接口：允许用户直接使用
      联机命令接口（交互式命令接口）：用户说一句，系统做一句
      脱机命令接口（批处理命令接口）：用户说一堆，系统做一堆
    程序接口：允许用户通过程序间接使用
      由一组系统调用组成，程序接口=系统调用=广义指令，如在程
      序中调用dll
    GUI：图形用户界面

3.对硬件资源的扩展：覆盖了软件的机器称为扩充机器，又称为虚拟机。

**现在很多CPU都是多核的



#系统调用

**系统调用会使处理器从用户态到核心态
**应用程序通过系统调用请求操作系统的服务。凡是与资源有关的操作，
  都必须通过系统调用，从而保证系统的稳定性和安全性。系统调用的
  相关处理需要在核心态下进行（因为需要特权指令）。
系统调用（按功能分类）
  1. 设备管理（这个别忘）
  2. 文件管理
  3. 进程管理
  4. 进程通信
  5. 内存管理
**有的库函数涉及系统调用，有的没涉及。如：取绝对值的库函数不涉及；
  而创建一个新文件的库函数涉及系统调用。
**系统调用背后的过程：
    传递系统调用参数->陷入指令trap（用户态）->系统调用服务程序（核心态）
    ->返回用户程序
    **发出系统调用请求是在用户态，系统调用的相应处理在核心态。
    **陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。



#操作系统的四大特征：
  **并发和共享是最基本的特征，互为存在条件的。
  **如果没有并发和共享就谈不上虚拟和异步。
  1. 并发
       并发和并行：并发是一段时间多个程序，并行是同一
                   时刻多个程序。      
  2. 共享：资源可供内存中多个并发执行的进程共同使用
        互斥共享：一个时间段只能一个进程访问资源
        同时共享：一个时间段可以有多个进程访问资源
  3. 虚拟
       一台物理机器虚拟成多台虚拟机器
       空分复用技术：如虚拟存储器技术
       时分复用技术：如虚拟处理器
  4. 异步
       走走停停，不知道向前推进的速度。
       但只要运行环境相同，os要保证程序的运行结果（
       如1+1=2这个结果是不能变的）相同。



#os的发展和分类
  1. 手工操作阶段
       **纸带打孔与否为0或1，
       主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低

  2. 批处理阶段
       a. 单道批处理系统
            **引入脱机输入/输出技术（先输出到磁带），有监督程序
            主要优点：缓解一定程度人机速度矛盾，资源利用率有所提升
            主要缺点：内存中仅一道程序运行，CPU大量时间等待I/O
       b. 多道批处理系统（os开始出现）
            **内存读入多道程序，引入中断，多个程序并发
            主要优点：程序并发执行，共享资源，资源利用率大幅提升
            主要缺点：用户响应时间长，没有人机交互

  3. 分时操作系统
       **以时间片为单位轮流为各个用户/作业服务，可人机交互
       主要优点：用户请求及时响应，有人机交互。多个用户可同时使用
                 一台计算机。
       主要缺点：不能优先处理一些紧急任务，不区分任务紧急性。

  4. 实时操作系统
       要在严格的时限内处理完事件，主要特点是及时性和可靠性
       分类：
         a. 硬实时系统：必须在规定时间内完成
              如：导弹控制系统、自动驾驶系统
         b. 软实时系统：偶尔可以违反
              如：12306订票系统
       主要优点：能优先响应紧急任务
       
  5. 网络操作系统
  6. 分布式操作系统
  7. 个人计算机操作系统

      

#操作系统实例：
  1.UNIX BSD
      UNIX -> BSD
  2.LINUX(在其学生时代写的)
      -> redhat, ubuntu
  3.Windows
  4.ios  macos
  5.Android

  **计算机桌面Windows大多，服务器、终端Linux大多
  **汇编语言是基于具体的硬件的，很难移植
  **CS：段寄存器

  

#操作系统的启动：
  DISK：存放操作系统，bootloader
  BIOS: 基本I/O处理系统，上电后检测外设，加载软件，把
        bootloader加载到内存中
  bootloader：加载os 
  POST（加电自检），寻找显卡和执行BIOS



#中断

**本质：发生中断就意味着需要操作系统介入，开展管理工作

  1. 当中断发生时，CPU立即进入核心态，使os获得计算机的
     控制器。有了中断，才能实现多道程序并发执行。

  2. 用户态到核心态是通过中断实现的，并且中断是唯一途径。

  3. 核心态到用户态的切换是通过执行一个特权指令，将程序
     状态字PSW的标志位设置为用户态。

中断的分类
  1. 内中断（也称异常、例外、陷入） =》信号来源是CPU内部，和当前指令有关
        a. 自愿中断：指令中断：trap中断
        b. 强迫中断：硬件故障（注意）和软件中断

  2. 外中断（中断）                 =》信号来源是CPU外部，和当前指令无关
        a. 外设请求
        b. 人工干预：用户强行终止



#
指令（操作码、地址码）
  1. 特权指令：如内存清零指令（不允许用户程序使用）
  2. 非特权指令：如普通的运算指令，两种态下都可执行
 
处理器状态：根据程序状态字寄存器PSW某个标志位
  1. 用户态（目态）：只能执行非特权指令
  2. 核心态（管态）：特权指令、非特权指令都可执行

程序：
  1. 内核程序：系统的管理者
  2. 应用程序： 

操作系统
  1. 内核（更靠近硬件）
       时钟管理、中断处理、原语（都有，更核心的）
       对系统资源进行管理：进程管理、存储器管理、设备管理等（有些内核没有）
  2. 非内核功能

**内核是计算机上配置的底层软件，是os最基本、核心的部分。

os的体系结构
  1. 大内核：主要功能都作为内核
       优点：高性能
       缺点：内核代码庞大，难以维护

  2. 微内核：保留最基本的
       优点：结构清晰，方便维护
       缺点：频繁地在核心态和用户态切换，性能低



#进程
  
**程序：指令序列

**程序段、数据段、PCB组成进程实体（进程映像），进程实体
  简称为进程。创建进程，实质上就是创建进程实体中的PCB，
  撤销进程实质上就是撤销进程实体中的PCB。

**PCB是进程存在的唯一标准。

进程定义：
  定义均强调了动态性，动态性是进程最基本的特征
  1. 进程是程序的一次执行过程。
  2. 进程是一个程序及其数据在处理机上顺序执行时所
     发生的活动。
  3. 进程是具有独立功能的程序在数据集合上运行的过程，
     是系统进行资源分配和调度的一个独立单位。  
  4. 进程是进程实体的运行过程，是系统进行资源分配和调度
     的一个独立单位。（注意是独立单位）

  例：任务管理器中各个进程。

  严格来说，两者不一样，进程实体是静态的，进程是动态的。
  但是一般认为两者一样，可以说进程由程序段、数据段、PCB
  三部分组成。

#进程控制块PCB的组成：进程的管理者（os）所需的数据都在PCB中，而程序
                      本身的允许所需数据在程序段和数据段中
  1. 进程描述信息
       进程标识符PID：操作系统分配的唯一的不重复的ID
       用户标识符UID
  2. 进程控制和管理信息
       进程当前状态
       进程优先级
  3. 资源分配清单
       程序段指针
       数据段指针
       键盘
       鼠标
  4. 处理机相关信息
       各种寄存器值：进程会切换故需要保存在PCB中

#进程的组织方式：多个进程之间的组织方式
  1. 链接方式：
       按照进程状态将PCB分为多个队列，os持有指向
       各个队列的指针。队列之间用指针连接。
         执行指针：指向运行态的进程
         就绪队列指针：指向就绪态的进程
         阻塞队列指针：指向阻塞态的进程
       
  2. 索引方式：
       按照进程状态的不同，建立几张索引表，os持有
       指向各个索引表的指针。
         执行指针
         就绪表指针
         阻塞表指针

#进程的特征：
  1. 动态性：进程是程序的一次执行
  2. 并发性：
  3. 独立性：独立运行、获得资源、接受调度
             进程是资源分配、接受调度的基本单位。（注意线程）
  4. 异步性：
  5. 结构性：每个进程都有一个PCB，由程序段、数据段和
             PCB组成

#进程的状态：
  三种基本状态：
    1. 运行态：占有CPU
         双核环境可以有两个进程在运行态
    2. 就绪态：拥有除CPU外所有资源
    3. 阻塞态（等待态）：缺少某一资源和CPU

  另外两种状态：
    1. 创建态：进程正在被创建，os为其分配资源，初始化PCB
    2. 结束态（终止态）：进程正在撤销，os回收资源，撤销PCB

#进程状态的转换：
  就绪态->运行态：进程被调度
  运行态->就绪态：时间片到，或CPU被高优先级进程抢占
  运行态->阻塞态：等待资源分配或某时间发生     
  阻塞态->就绪态：资源分配到位或等待的事件发生

  运行态到阻塞态是进程自身做出的主动行为
  阻塞态到就绪态不是进程自身控制的，是被动的

  不能由阻塞态直接到运行态，也不能由就绪态直接到阻塞态。



10/22

#进程控制：
  进程控制就是实现进程状态的转换
  无非：PCB修改、队列移动，资源分配/回收
  
**用原语实现进程控制。原语的特点是执行期间不允许中断。这种不允许中断的操作称为原子操作。
**原语采用关中断指令和开中断指令实现。该两项指令权限非常高，是只允许在核心态下执行的特
  权指令。原语属于核心态，运行在核心态下。原语是一种特殊的程序。

  关中断指令
  原语代码1
  原语代码2
  开中断指令
  代码3
  代码4

所有原语都做三类事情：
  修改PCB，修改队列，分配/回收资源

进程的创建：
  1. 创建原语：
       申请空白PCB
       分配资源
       初始化PCB
       将PCB插入就绪队列
  2. 引起进程创建的事件：
       用户登录：分时系统中，会为新用户建立进程
       作业调度：多道批处理系统中，当有新作业放入内存中时，
       提供服务
       应用请求

进程的终止：
  1. 撤销原语：
       找到PCB
       若进程正在运行，剥夺CPU
       终止其所有子程序
       回收资源
       删除PCB
  2. 引起进程终止的事件：
       正常结束
       异常结束
       外界干预

进程的阻塞：
  1. 阻塞原语：
       找到PCB
       保护运行现场，PCB状态信息设置为阻塞态，暂停进程
       将PCB插入相应事件的等待队列
  2. 引起进程阻塞的事件：
       等待分配资源
       等待其他进程完成工作（某个事件发生）

进程的唤醒：
  1. 唤醒原语：
       找到PCB
       从等待队列移除，进程状态设置为就绪态
       PCB插入就绪队列
  2. 引起进程唤醒的事件：
       等待的事件发生

**阻塞原语和唤醒原语必须成对地使用，因为都是由于一个等待事件



#进程通信：进程通信就是进程之间的信息交换

**因为进程是分配资源的单位，各进程拥有的内存空间独立。为了安全，一个进程
  不能直接访问另一个进程的地址空间，因此需要进程通信。
  
  1. 共享存储
       **为通信的进程分配一个共享空间（多个进程对其访问必须是互斥的）
       使用P、V操作

       a. 基于数据结构的共享
            （如长度为10的数组）速度慢、限制多，低级通信
       b. 基于存储区的共享
            存储区中数据的形式、位置都由进程控制而不是os
            速度更快，高级通信

  2. 消息传递
       **数据交换以格式化的消息为单位。通过“发送消息/接收消息”两个
         原语进行数据交换。格式化信息包括消息头和消息体。
       
       a. 直接通信方式
            消息直接挂到接收进程的消息缓冲队列上
       b. 间接（信箱）通信方式
            先发送到中间实体（信箱）

  3. 管道通信
       a. 管道是一个共享文件，pipe文件。是在内存中开辟一个大小
          固定的缓冲区。
       b. 管道只能采用半双工通信。如果要实现双向同时通信，要设置
          两个管道。各个进程要互斥地访问管道。
       c. 数据以字符流的形式写入管道，当管道写满时，写进程的write（）
          系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部
          取走后，管道变空，读进程的read（）系统调用将被阻塞。
       d. 如果没有写满，就不允许读。如果没有读空，就不允许写。
       e. 数据一旦被读出，就会被抛弃，故读进程最多只能有一个，否在可能
          会读错数据。



#线程

**两个进程QQ和音乐，而QQ进程中又有视频、传送文件两个线程

  1. 在传统的进程中只能串行地执行程序，通过引入线程来增加并发
  2. 传统的进程是程序执行流的最小单位，现在线程是程序执行流的最小单位
  3. 线程可以理解为“轻量级进程”，线程是一个基本的CPU执行单元
  4. 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位（注意）
  5. 相比进程间并发，线程间并发如果在同一进程内线程切换，不需要切换进程
     环境，系统开销小。
  6. 引入后并发性和系统开销都变好了


#线程的属性：
  1. 每个线程都有线程ID、线程控制块TCB
  2. 线程也有就绪、阻塞、运行三种基本状态
  3. 几乎不拥有系统资源
  4. 同一进程不同线程共享进程资源
  5. 共享内存地址空间，线程通信甚至无需系统干预
  6. 不同进程中的线程切换会引起进程切换


#线程的实现方式
  1. 用户级线程ULT
       a. 由应用程序通过线程库实现，所有的线程管理工作都由应用
          程序负责（包括线程切换）
       b. 线程切换在用户态下即可完成，无需操作系统干预
       c. 用户级线程对用户不透明，对操作系统透明（注意os是看不到的）

  2. 内核级线程KLT：只有这个是处理机分配的单位，用户级线程不是
       a. 线程的管理工作由操作系统内核完成，内核级线程的
          切换必须在核心态下完成

  3. 在同时支持用户级线程和内核级线程的系统中，可采用两者结合的方式，
     将n个用户级线程映射到m个内核级线程上（n>=m）
     **os只“看得见”内核级线程，因此只有内核级线程才是处理机
       分配的单位。若某进程有两个内核级线程，三个用户级线程，在用户看
       来，该进程只有三个线程。但即使在4核处理机上运行，最多只能被分配
       到两个核，最多只有两个用户级线程并行执行。


#多线程模型问题
  1. 多对一模型：多个用户级线程映射到一个内核级线程。每个用户进程
                 只对应一个内核级线程。
       a. 优点：用户级线程的切换在用户空间，不需要到核心态，开销小，
                效率高。
       b. 缺点：当一个用户级线程阻塞后，整个进程都会阻塞，并发度不高，
                多个线程不可在多核处理机上并行运行（因为内核级线程是
                处理机调度的基本单位）

  2. 一对一模型：一个用户级线程映射到一个内核级线程。
       a. 优点：一个线程阻塞后，别的线程还能执行，并发能力强。多线程
                可以在多核处理机上并行执行。
       b. 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核
               完成，需要切换到核心态，开销大。

  3. 多对多模型：将n个用户级线程映射到m个内核级线程上（n>=m）
       克服了多对一模型并发度不高，一对一模型一个用户进程占有太多内核级
       线程，开销太大的问题。



#处理机调度

**调度：根据某种规则决定处理任务的先后

**处理机调度：按照某种算法选择一个进程分配处理机

三个层次：
  1. 高级调度（作业调度）
       a. 从外存上后备队列挑选一个或多个作业，分配内存等必要资源，建立
          相应的进程（PCB），以使其获得竞争处理机的权利。
       b. 高级调度是外存和内存之间的调度。每个作业只调入一次，调出一次。
          作业调入时建立PCB，调出时才撤销PCB。
       c. 对进程状态影响：无->创建态->就绪态
  
  2. 中级调度（内存调度）
       a. 虚拟存储技术提高内存利用率和系统吞吐量。
       b. 暂时调到外存等待的进程状态为挂起状态。PCB位置不变一直在内存中，
          记录该进程在外存中位置。被挂起的进程PCB放到挂起队列。
       c. 中级调度（内存调度）就是要决定哪个挂起状态的进程重新进入内存。
       d. 一个进程可能被多次调出、调入内存，因此中级调度的频率比高级调度
          高。
       e. 对进程状态影响：挂起态->就绪态 （阻塞挂起->阻塞态）
       **挂起和阻塞都是暂时不能获得CPU，但挂起态将进程映像调到外存去了，
         阻塞态进程映像还在内存中。

  3. 低级调度（进程调度）
       a. 主要任务就是选取进程分配处理机。
       b. 进程调度是os最基本的调度，频率很高，一般几十毫秒一次。
       c. 对进程状态影响: 就绪态->运行态


#进程调度
  1. 时机
       a. 需要进行进程调度
            当前运行的进程主动放弃处理机（包括发生异常）
            当前运行的进程被动放弃处理机
       b. 不能进行进程调度
            处理中断的过程中

            进程在os内核程序临界区中
                （但进程处于普通临界区是可以进行处理机调度）
                临界资源：一个时间段只允许一个进程使用的资源
                临界区：访问临界资源的那段代码
                内核程序临界区访问内核数据结构（如就绪队列），没退出临界
                区时会给就绪队列上锁，就不能切换。
            在原子操作过程中（原语）

  2. 切换与过程
       切换过程主要完成了：对原来运行进程数据的保存，对新进程数据的恢复。
       进程的调度、切换是有代价的，如果频繁开销会很大。

  3. 方式
       a. 非剥夺调度方式（非抢占式）：只允许进程主动放弃处理机
       b. 剥夺调度方式（抢占式）：允许被动放弃处理机（更适合分时、实时os）


#调度算法的评价指标
  1. CPU利用率
       利用率 = 忙碌的时间 / 总时间
     
  2. 系统吞吐量：单位时间完成作业的数量
       系统吞吐量 = 总的作业数 / 总时间

  3. 周转时间
       周转时间 = 作业完成时间 - 作业提交时间
       平均周转时间 = 各作业周转时间之和 / 作业数
       带权周转时间 = 作业周转时间 / 作业实际运行时间
         以上三者都是越小越好
       平均带权周转时间 = 各作业带权周转时间之和 / 作业数

  4. 等待时间
       a. 进程等待时间 = 建立进程后的等待时间
       b. 作业等待时间 = 在外存后备队列中等待时间 +  建立进程后的等待时间
       
  5. 响应时间：用户提交请求到首次响应的时间
       

#调度算法
  1. 先来先服务FCFS：等待时间越久的越先得到服务
       a. 用于作业调度，考虑哪个作业先到达后备队列；
          用于进程调度，考虑哪个进程先到达就绪队列。
       b. 非抢占式的
       c. 
       d. 
  
  2. 短作业优先SJF


  3. 高响应比优先HRRN




#死锁
 
死锁、饥饿、死循环
  共同点：都是进程无法向前推进
  区别：
    1. 死锁一定是循环等待他方手里的资源，进程至少有两个，处于死锁的进程一定
       是阻塞态。
    2. 饥饿是可能只有一个进程发生饥饿，处于饥饿的进程可能是阻塞态或就绪态。
         （饥饿：长期得不到服务）
    3. 可能只有一个进程发生死循环，可以上处理机运行，可以是运行态。死锁和饥饿
       是管理者（操作系统）的问题，死循环是被管理者的问题（代码没写好）。
  

死锁产生的必要条件（必须全部满足）
  1. 互斥
  2. 不剥夺：资源未使用完不能由其他进程强行夺走
  3. 请求并保持：已保持了至少一个资源，又提出新的资源请求
  4. 循环等待
       发生死锁一定有循环等待，但是发生循环等待不一定有死锁

死锁的处理策略：
  1. 预防死锁。（静态策略）破坏必要条件。
  2. 避免死锁。（动态策略）防止系统进入不安全状态（如银行家算法）。
  3. 死锁的检测和解除。允许死锁发生，检测并采取措施解除死锁。


#预防死锁
  1. 破坏互斥条件
       把只能互斥使用改为允许共享使用（但很多时候都不能破坏）

  2. 破坏不剥夺条件
       方案一：某个进程申请新资源不满足时，则释放其所有资源
       方案二：高优先级进程抢占低优先级进程资源
       
       缺点：
         1. 复杂
         2. 可能造成前一工作失效，适合CPU
         3. 反复申请释放资源增加开销，减小吞吐量
         4. 方案一可能导致饥饿

  3. 破坏请求并保持条件
       静态分配：进程在运行前，一次申请完所需资源，若不满足则
                 不运行。一旦运行，一直拥有那些资源，并不能申请
                 其他资源。
       缺点：
         1. 有些资源可能只需很短时间，资源利用率很低
         2. 可能导致饥饿

  4. 破坏循环等待条件
       顺序资源分配法：给资源编号，每个进程必须按编号递增顺序申请
                       资源，同类资源（编号相同）一次申请完。
       缺点：
         1. 不方便增加新设备
         2. 进程使用资源顺序可能和编号顺序不同，造成资源浪费
         3. 用户编程麻烦


10/24

#避免死锁
  1. 什么是安全序列
       如果系统按某序列进行资源分配，每个进程都能顺利完成，则
       该序列为安全序列，系统为安全状态

  2. 什么是系统的不安全状态，与死锁有什么联系
       a. 如果系统找不到任何一个安全序列，则系统进入不安全状态。
       b. 出于安全状态，一定不会发生死锁；处于不安全状态，有可能发生死锁
          （但发生死锁一定是在不安全状态）
       c. 在资源分配前判断资源分配是否会进入不安全状态，从而判断是否分配，
          这是银行家算法的核心思想

  3. 如何避免系统进入不安全状态：银行家算法（此处视频有计算）
       

#死锁的检测和解除
  1. 死锁的检测
       数据结构：资源分配图
         两种结点
           进程结点：对应一个进程（圆形）
           资源结点：对应一类资源（一般用矩形表示，其中小圆点代表资源数量）
         两种边
           请求边（进程结点->资源结点）：一条边代表想申请一个资源
           分配边（资源结点->进程结点）：一条边代表分配了一个资源
       
       依次消除与不阻塞进程相连的边，直到无边可消
       若能消除所有的边，则该图是可完全简化的，一定没有发生死锁
       若不能消除所有的边，则发生了死锁
       最终还连着边的进程就是处于死锁状态的进程（其他可以简化的进程不是死锁状态）

  2. 死锁的解除
       （一旦检测出死锁的发生，应该立即解除死锁）
       a. 资源剥夺法
            挂起某些死锁进程，将其资源分配给其他死锁进程。
              （挂起进程可能饥饿）
       b. 撤销进程法（终止进程法）
            撤销部分或全部死锁进程
              （代价大，可能进程已接近完成）
       c. 进程回退法
            让一个或多个进程回退到足以避免死锁的状态。 
              （需要记录历史信息）

       考虑下手进程
         1. 进程优先级
         2. 已执行时间
         3. 还需时间
         4. 已使用资源
         5. 交互式还是批处理式的



#内存的基础知识
  1. 内存有何作用
       a. 程序执行前要先放到内存中才能被CPU处理，缓解CPU和外存速度矛盾
       b. 如果计算机是按字节编址，则每个存储单元大小为1字节（1B）；
          如果字长为16位的计算机是按字编址，则每个存储单元大小为一个字。      
       c. 问地址长度就是问要用多少二进制位表示

  2. 进程运行的基本原理
       源文件编译成目标文件.o（机器语言，采用逻辑地址），链接之后也用
       逻辑地址。再通过装入程序将链接而成的装入模块装入内存运行。
 
       链接之后形成完整的逻辑地址，装入之后形成物理地址

       链接的三种方式
         1. 静态链接
              运行前，将各目标模块和库函数链接成一个完整的可执行文件（装入模块）
          
         2. 装入时动态链接
              边装入边链接

         3. 运行时动态链接
              再执行时需要该目标模块才进行链接
      
       装入的三种方式（用三种不同的方法完成逻辑地址到物理地址的转换）
         1. 绝对装入
              在编译时，如果知道程序将放到内存哪个位置，编译程序将产生
              绝对地址的目标代码。（这个地址不一定是之前的逻辑地址）
              （只适合单道程序环境）

         2. 静态重定位（可重定位装入）
              装入时对地址进行重定位，将逻辑地址变换为物理地址
               （地址变换是在装入时一次完成的）
               （装入时必须分配所需的全部内存空间，不够则不能装入。一旦
                 装入，运行期间不能移动，不能申请新的内存空间）

         3. 动态重定位（动态运行时装入）
              装入内存后仍是逻辑地址，等到程序真正要执行时才进行地址转换
              
              重定位寄存器：存放装入模块存放的起始地址，运行时与逻辑地址相加

              （允许运行时程序在内存中移动，可将程序分配到不连续的内存，
                运行前可只装入部分代码，运行期间动态申请内存）



#文件管理














#磁盘的结构
  1. 磁盘、磁道、扇区
       a. 磁盘表面由磁性物质组成，用磁性物质记录二进制数据
       b. 盘面被划分成一个个同心圆的磁道
       c. 一个磁道又分为一个个扇区，扇区存放数据量相同（故最内侧扇区数据密度最大）
  
  2. 如何在磁盘中读/写数据
       把磁头移动到想读/写的扇区所在的磁道，转动划过时可修改

  3. 盘面、柱面
       竖直方向有很多盘面，每个盘面上都有一个磁头，所有磁头连接在一个磁臂上，共进退
       一个盘片可能有两个盘面（正反两面） 
       所有盘面中相对位置相同的磁道组成柱面

  4. 磁盘的物理地址
       可用（柱面号，盘面号，扇区号）确定任意一个磁盘块的位置
 
       根据柱面号移动磁臂，磁头指向柱面，激活盘面号的磁头，当划过指定
       扇区时，完成读/写

  5. 磁盘的分类
       磁头可以移动的称为移动头磁盘，磁臂可以来回伸缩带动磁头定位磁道。
       磁头不可移动的称为固定头磁盘，每个磁道都有一个磁头

       盘片可以更换的称为可换盘磁盘
       盘片不可更换的称为固定盘磁盘


#磁盘调度算法
  1. 一次磁盘读/写需要的时间（延迟时间和传输时间是os无法优化的）
       寻找时间（寻道时间）Ts：磁头移动到磁道
         启动磁头臂时间s（注意） 跨域一个磁道时间m 跨越n个磁道
         Ts = s + m * n

       延迟时间Tr：旋转磁盘，磁头到目标扇区的时间
         磁盘转速r
         平均延迟时间Tr = 1 / （2r）

       传输时间Tt：从磁盘读入/写出数据的时间
         磁盘转速r 读/写的字节数b 每个磁道上字节数N
         传输时间Tt = (1/r)*(b/N) = b / (rN)

       总的平均存取时间 Ta = Ts + Tr + Tt

  2. 磁盘调度算法(影响寻道时间)
       a. 先来先服务（FCFS） 
            **根据进程请求访问磁盘先后顺序进行调度
            优点：公平；如果要访问的磁道比较集中，性能还行
            缺点：如果要访问的磁道很分散，则性能很差

       b. 最短寻找时间优先（SSTF）
            **优先处理与当前磁道最近磁道，保证目前最优，但不能保证
              总体最优（贪心算法的思想）
            优点：性能较好，平局寻道时间较短
            缺点：可能产生饥饿

       c. 扫描算法（SCAN）
            **只有磁头移动到最外侧磁道才能往内移动，移动到最内侧磁道
              才能往外移动，也叫电梯算法。（哪怕没有请求也要到最外和最内）
            优点：性能较好，平局寻道时间较短，不会产生饥饿
            缺点：要移动到最外和最内侧；各个位置磁道响应频率不均匀

            LOOK调度算法：如果在磁头移动方向上没有请求了，可以立即改变
                          磁头方向（解决缺点一）

       d. 循环扫描算法（C-SCAN）
            **只有磁头朝某个方向移动才处理访问请求，返回时快速移动到起事端
              而不处理任何请求（解决缺点二）
            缺点：只有到达最边上才能返回

            C-LOOK算法：如果在磁头移动方向上没有请求了，可以立即改变磁头方向
                          
       **若题目中无特别说明，SCAN算法就是LOOK,C-SCAN就是C-LOOK


#减少磁盘延迟时间的方法
  因为磁头读完一个扇区需要时间处理不能立刻读下一个扇区，需要多转一圈。

  a. 交替编号：让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻
               辑扇区所需要的延迟时间更小

  是柱面号、盘面号 而不是 盘面号、柱面号 的原因
    读取地址连续的磁盘块时，前者可以减少磁头移动消耗的时间

  b. 错位命名：不同盘面同样位置的扇区编号不同  


#磁盘的管理
  1. 磁盘初始化
      a. 低级格式化（物理格式化）：将磁道划分成扇区
           扇区分为头、数据区域、尾，头、尾存储管理信息
      b. 磁盘分区：每个分区由若干柱面（注意）组成（即熟悉的C盘、D盘、E盘）
      c. 逻辑格式化：创建文件系统

  2. 引导块（拥有该分区的磁盘叫启动磁盘或系统磁盘）
       引导块（启动块、启动分区）存放完整自举程序，位置固定。
       开机时先运行ROM中自举装入程序找到引导块，将完整的自举程序读入
       内存，完成初始化。（自举装入程序不可更该，装入程序可更新）

  3. 坏块的管理
       a. 简单磁盘，在逻辑格式化（建立文件系统）时坏块检查，在FAT表明
          坏扇区，对os不透明

       b. 复杂磁盘，有坏块链表。低级格式化就初始化坏块链，有扇区备用，
          坏块对os透明



#设备管理（主机外部设备）

#I/O设备
  1. 什么是I/O设备：输入/输出设备（注意）
       如：鼠标、显示器、移动硬盘、U盘

  2. 按使用特性分类
       人机交互类外部设备：传输速度慢
       存储设备：传输速度快
       网络通信设备：速度中间

  3. 按传输速率分类
       低速设备：鼠标、键盘
       中速设备：激光打印机
       高速设备：磁盘

  4. 按信息交换的单位分类
       块设备：磁盘   速度快，可寻址
       字符设备：鼠标、键盘   速度慢，不可寻址，常用中断驱动

10/23


#I/0控制器
  **I/O由机械部件和电子部件组成，CPU无法直接控制I/O设备的机械部件，
    CPU控制I/O控制器，而I/O控制器控制设备的机械部件。一个I/O控
    制器可能对应多个设备，故控制、状态、数据寄存器可能有多个，
    产生了寄存器编址。

  寄存器编址方式
    1. 内存映像I/O：和内存一起编址
         简洁指令，但占据了内存编址
    2. 寄存器独立编址
         要设置专门指令，不占据内存编址

  功能：
    1. 接受和识别CPU发出的命令：其中控制寄存器存放命令
    2. 向CPU报告设备状态：其中有状态寄存器
    3. 数据交换：其中有数据寄存器
    4. 地址识别：识别是哪个寄存器

  组成：（注意流程）
    1. CPU和控制器之间的接口
         控制寄存器、状态寄存器、数据寄存器
    2. I/O逻辑
    3. CPU和设备之间的接口


#I/O控制方式（每个阶段都是优化上一个，减少CPU干预，提高CPU利用率）
  1. 程序直接控制方式
       a. 流程
            CPU给I/O模块发送读命令->CPU读取I/O模块状态->检查状态
            ->从I/O模块中读取字（I/O寄存器到CPU寄存器）->往内存写入字
            ->完成（CPU会检查这个，如果没有回到开头）
       **若设备未就绪，CPU会不断轮询（关键）设备状态

       b. CPU干预度
            很频繁，I/O操作开始前、后需要CPU，在等待I/O时CPU
            需要不断地轮询

       c. 数据传送单位
            字

       d. 数据的流向
            读操作：I/O设备->CPU->内存
            写操作：内存->CPU->I/O设备
        
       e. 优点
            实现简单
       
       f. 缺点
            CPU轮询，利用率低

  2. 中断驱动方式
       a. 流程
            引入中断（关键），CPU发出读命令后先去做其他事情，等I/O模块
            就绪发送中断请求。
            **CPU会在每个指令周期末尾检查中断
            **需要保存、恢复运行环境，有一定开销（每次中断只能读取一个字）

       b. CPU干预度
            I/O操作开始前、后需要CPU

       c. 数据传送单位
            字

       d. 数据的流向
            读操作：I/O设备->CPU->内存
            写操作：内存->CPU->I/O设备
        
       e. 优点
            同程序直接控制方式相比，CPU和I/O可并行执行，CPU利用率提高

       f. 缺点
            频繁的中断会消耗较多CPU时间，I/O和内存传输需要CPU

  3. DMA方式（DMA:直接存储器存取）
       a. 流程

       b. CPU干预度
            传输一个或多个数据块的开始和结束（结束会给CPU发送中断请求）

       c. 数据传送单位
            块（若读入是连续的块，则写入内存中也必须是连续的）

       d. 数据的流向
            设备直接到内存，内存直接到设备

       e. 优点
            以块为单位，CPU介入频率降低，过程不需要CPU，传输效率提高，
            CPU和I/O并行性提高

       f. 缺点
            CPU发出一条命令，只能读/写一个或多个连续的数据块
            （若需要离散的，需要多条命令）

       g. DMA控制器
            1. 主机-控制器接口
                 数据寄存器DR
                 内存地址寄存器MAR
                 数据计数器DC
                 命令/状态寄存器CR
            2. I/O控制逻辑
            3. 块设备-控制器接口

  4. 通道控制方式（通道是一种硬件，可识别并执行通道指令）
       **一个通道可以控制多个I/O控制器，而一个I/O控制器可以控制
         多个I/O设备
       a. 流程

       b. CPU干预度
            传输一组数据块的开始和结束（结束会给CPU发送中断请求）

       c. 数据传送单位
            一组数据块

       d. 数据的流向
            设备直接到内存，内存直接到设备

       e. 优点
            CPU、通道、I/O可并行执行，资源利用率很高

       f. 缺点
            需要专门的硬件



#I/O软件层次结构
  1. 用户层软件
       提供与用户交互接口（如库函数）（包括假脱机技术）

  2. 设备独立性软件（设备无关性软件）：与设备硬件特性功能几乎都在这层实现  
       提供系统调用
       I/O调度（注意）
       设备保护
       差错处理（设备）
       设备的分配与回收
       数据缓冲区管理
       建立逻辑设备名到物理设备名的映射；选择驱动程序
         逻辑设备表LUT（有驱动程序入口地址）
       
  3. 设备驱动程序
       控制硬件
       （驱动程序一般以独立进程方式存在）

  4. 中断处理程序
       从控制器读出设备状态，若正常结束，则读出一个字到CPU
       
  硬件：执行I/O操作
    机械部分、电子部分

  **2到4层属于os内核部分，即I/O系统或I/O核心子系统
  **每层都向上提供服务，只有中断处理程序和设备驱动程序直接和硬件打交道


#I/O核心子系统
  （大纲中包括假脱机技术这一内容）

I/O调度：根据算法确定处理I/O请求顺序

设备保护：设备被看作特殊的文件，有其FCB，不同用户对各文件访问权限
          不同（如：只读、读和写）


#假脱机技术（SPOOLing技术）
  1. 什么是脱机技术
       脱离主机的控制进行输入/输出（如单道批处理系统中
       外围控制机控制输入输出到磁带上）

  2. 假脱机技术实现原理
       **假脱机技术（SPOOLing技术）：用软件的方式模拟脱机技术

                     输入进程    输出进程
      输入设备             输入缓冲区            输入井
     
      输出设备             输出缓冲区            输出井
                                  内存               磁盘

    输入井模拟脱机输入时的磁带
    输出井模拟脱机输出时的磁带

    输入进程模拟脱机输入时的外围控制机
    输出进程模拟脱机输出时的外围控制机

    假脱机技术需要并发

  3. 共享打印机原理
    **独占式设备：只允许各个进程穿行使用的设备（打印机是独占式的）
    **共享设备：允许多个进程“同时”使用的设备

    利用假脱机技术，将一台物理设备虚拟成逻辑上的多台设备，可将独占式
    设备改造成共享设备。
    
    多个用户进程提出打印请求时，系统答应请求，但并不把打印机分配给
    他们。
    a. 在磁盘输出井申请一个空白的缓冲区，将要打印数据送入
    b. 为用户进程申请空白的打印请求表，打印请求填入表中（说明打印数据位置等），
       将表挂到假脱机文件队列上



#设备的分配与回收
  1. 设备分配时应考虑的因素
       设备的固有属性
         独占设备、共享设备、虚拟设备（采用假脱机技术将独占设备变为虚拟的共享设备）

       设备分配算法
         先来先服务
         优先级高者优先
         短任务优先

       设备分配中的安全性
         安全分配方式：为进程分配一个设备后将进程阻塞，I/O完成后唤醒
           优点：破坏“请求并保持”，不会死锁
           缺点：对于一个进程来说，CPU和I/O只能串行工作
         不安全分配方式：为进程分配I/O设备后进程继续执行，还可发出新的
                         I/O请求。只有当I/O请求不满足时才阻塞进程
           优点：对于一个进程，CPU和I/O可以并行执行
           缺点：有可能死锁

  2. 静态分配与动态分配
       静态分配：进程运行前为其分配全部资源，运行结束后归还资源
         破坏请求并保持，不会死锁
       动态分配：进程运行过程中动态申请资源
         有可能死锁


  3. 设备分配管理中的数据结构
       **一个通道控制多个I/O控制器，一个I/O控制器控制多个设备

       a. 设备控制表DCT：系统为每个设备配置一张DCT
            其中有指向控制器表的指针
       b. 控制器控制表COCT：每个设备控制器都以一张COCT
            其中有指向通道控制表的指针
       c. 通道控制表CHCT：每个通道都有一张CHCT
       d. 系统设备表SDT：记录系统中全部设备，每个设备对应一个表目

  4. 设备分配的步骤
       a. 根据进程请求的物理设备名查找SDT
       b. 根据SDT找到DCT，若设备忙碌将进程的PCB挂到设备等待队列中，
          不忙碌则将设备分配给进程
       c. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列
          中，不忙碌则将控制器分配给进程
       d. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，
          不忙碌则将通道分配给进程。
       （只有设备、控制器、通道都分配成功，才算分配成功）

       缺点：
         1. 必须使用物理设备名，不方便编程
         2. 更换设备则无法使用
         3. 若请求的正在忙碌，不能使用同类型设备，进程要阻塞等待

  5. 设备分配的改进方法
       根据进程请求的逻辑设备名查找SDT
         （该逻辑设备名其实是设备类型）
       查找SDT，找到该类型空闲的设备分配，在逻辑设备表LUT新增一个表项
       。。。。。。
       （逻辑设备表有逻辑设备名和物理设备名映射关系，以及驱动程序入口地址）
       当第二次请求该逻辑设备名，os不用SDT，用LUT即知物理设备及其
         驱动程序入口地址。
 
       a. 若整个系统只有一张LUT，各用户的逻辑设备名不许重复
       b. 若每个用户有一张LUT，可重复



#缓冲区管理（此处视频有计算内容）
  1. 什么是缓冲区，有什么作用
       a. 专门硬件寄存器作为缓冲区成本较高，容量也较小，适合高速的
       b. 一般使用内存作为缓冲区
 
       缓冲区的作用
         1. 缓解CPU和I/O设备速度不匹配
         2. 减少CPU的中断频率（如每读一字中断一次），放宽CPU中断相应时间的限制
         3. 解决数据颗粒度不匹配的问题（如字和块）
         4. 提高CPU与I/O设备的并行性

  2. 单缓冲
       os分配一个缓冲区。
       （若没说明，一个缓冲区的大小就是一个块）
       **当缓冲区数据非空时，不能冲入数据，只能传出；当缓冲区为空时，可以往
         缓冲区冲入数据，但必须充满之后才能传出。
         
  3. 双缓冲
       os分配两个缓冲区

  4. 循环缓冲
       多个大小相等的缓冲区连接成一个循环队列

  5. 缓冲池
       缓冲池由公用的缓冲区组成。
       a. 空缓冲队列
       b. 装满输入数据的缓冲队列（输入队列）
       c. 装满输出数据的缓冲队列（输出队列）

       a. 收容输入数据 的工作缓冲区
       b. 收容输出数据 的工作缓冲区
       c. 提取输入数据 的工作缓冲区
       d. 提取输出数据 的工作缓冲区














